1. cpp数据类型

|数据类型|大小（字节）|范围|
|---|---|---|
| `int`  |  4 |  -2,147,483,648 到 2,147,483,647 |
|`unsigned int`|4|0 到 4,294,967,295|
|`unsigned long`|4|	0 到 4,294,967,295|
|`long`|4|-2,147,483,648 到 2,147,483,647|
|`long long`|8|-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807|
|`short`|2|-32,768 到 32,767|
|`unsigned short`|2|	0 到 65,535|
|`float`|4|1.2E-38 到 3.4E+38|
|`double`|8|2.3E-308 到 1.7E+308|
|`char`|1|-128 到 127 或 0 到 255|
|`unsigned char`|1|0 到 255|
|`bool`|1|true 或 false|

2. 规则

根据 C++ 标准（以及 C 语言标准）的规定：

> **任何** 以两个下划线（`__`）开头的标识符，或 **以一个下划线紧跟大写字母**（如 `_A`、`_MyVar`）开头的标识符，都是 **保留给实现（Implementation）使用** 的。

换言之，**编译器、标准库实现、运行时库** 等都可以使用这些名称，而 **用户代码不应自行定义此类名称**，否则有可能与实现内部的标识符发生冲突，导致 **不可预期的行为**。  

具体规则可以概括如下：

1. **`__Xxx`**（两个下划线开头）这样的标识符，属于实现保留。  
2. **`_Xxx`**（一个下划线 + 大写字母开头）也属于实现保留。  
3. 在某些标准版本或参考文档中，还明确规定：以单下划线开头的标识符如果出现在 **全局命名空间（global namespace）** 中，也属于实现保留。  

之所以有这样的规定，是为了让编译器和标准库在实现 **内部接口**、**特殊宏**、**私有函数** 等时，可以使用这一命名习惯来避免和用户命名冲突。如果用户代码也使用了同样的命名方式，就可能导致 **编译冲突** 或 **运行时异常** 等不确定行为。

------------------------------------------------------------------------
在 C++ 中，关于以单个下划线开头的标识符，也有明确的规定：

- **全局命名空间中的标识符：**  
  任何在全局命名空间中以单个下划线开头的标识符都是保留给实现（如编译器和标准库）的。因此，不应在全局范围内定义以单下划线开头的名称。

- **局部或类作用域中的标识符：**  
  如果标识符在局部作用域（例如函数内部）或类的作用域中使用，以单下划线开头的标识符并不被严格保留。但是，建议避免使用这种命名方式，以免与实现的标识符冲突或引起混淆。


3. 怎样判断两个浮点数是否相等？

对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关

单精度有效保留6位
双精度有效保留12位
