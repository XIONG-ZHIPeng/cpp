1. struct 和 union 的区别

结构体struct：把不同类型的数据组合成一个整体。struct里每个成员都有自己独立的地址。sizeof(struct)是内存对齐后所有成员长度的加和。（引申出内存对齐的问题）

共同体union：各成员共享一段内存空间, 一个union变量的长度等于各成员中最长的长度，以达到节省空间的目的。所谓的共享不是指把多个成员同时装入一个union变量内, 而是指该union变量可被赋予任一成员值,但每次只能赋一种值, 赋入新值则冲去旧值。 sizeof(union)是最长的数据成员的长度。

2. struct的内存对齐规则
需要字节对齐的根本原因在于CPU访问数据的效率问题。假如没有字节对齐，那么一个double类型的变量会存储在4-11上（正常是0-7）这样计算机取这个数据的会会取两次，降低效率。而如果变量在自然对齐位置上，则只要一次就可以取出数据。

(1) 每个成员变量的地址必须是其类型对齐要求的倍数
	•	基础数据类型的对齐要求：
	•	char、bool：1 字节对齐
	•	short：2 字节对齐
	•	int、float：4 字节对齐
	•	double、long long：8 字节对齐
	•	指针：通常 4 或 8 字节对齐（取决于 32 位或 64 位系统）

⸻

(2) 结构体的总大小必须是「最严格对齐成员」的整数倍
	•	结构体的大小必须是 结构体内对齐要求最高的成员的对齐数 的整数倍，这样确保整个结构体在数组中按相同规则对齐。

⸻

(3) 编译器会在必要时添加填充字节 (padding)
	•	为了满足对齐规则，编译器会自动在成员之间或者结构体末尾添加 填充字节 (padding bytes)，避免因对齐问题导致访问性能下降。

3. new 和 delete 以及 malloc 和 free

	- 概念上的区别
    	- malloc/free是C++/C语言的标准库函数，而new/delete是C++的运算符。因此malloc仅仅只分配内存，而不会进行初始化类成员的工作，new不止分配内存，而且还是调用类的构造函数。
  	- 返回类型的安全性
    	- new操作符内存分配成功时候，返回的是对象类型的指针，不需要进行类型转换，从这个角度来说比较安全
    	- malloc内存分配成功则返回`void*`类型（泛型指针），必须通过强制类型转换将void* 转换成需要的类型。
  	- 分配失败后返回值也不同
    	- malloc失败，会返回空指针。
    	- new失败，默认是抛出异常，要捕获异常bad_alloc
4. 有了malloc/free为什么还要new/delete
对于一些非内部数据类型(eg:类对象)来说，光用maloc/free无法满足要求。对象在创建的同时要自动执行构造函数，对象在消亡的时候要自动执行析构函数，而由于malloc/free是库函数而不是运算符，不在编译器的控制权限内（库函数是编译好的代码由链接器链接到为我们的代码中），也就不能自动执行构造函数和析构函数。所以，在c++中需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理和释放内存工作的运算符delete。

5. new delete，new[] delete[]一定要配对使用吗？为什么？
- new和delete
new和delete主要是为了为那些自定义类型的对象开辟空间，因为这些对象在创建的时候要自动执行构造函数，消亡的时候要执行析构函数，对于自定义类型对象如果不配对使用的话，可能会出现没有析构干净的情况
- new[]和delete[]
我们再用new[]创建数组的时候，比如一个对象大小为N，则K个数组需要K*N个空间来构造。那当delete的时候如何知道这个数组空间的大小呢？我们会在new出来的这个空间的头部申请一个int类型的字节，4字节用来存储数组的长度，这样调用delete[]的时候就知道数组的大小，才会调用K次析构函数，释放K * N + 4字节大小的内存。

6. Const与指针
   1. 指向常量的指针表明不能通过解除引用运算符去改变其值，指向的变量是常量
   2. 常量指针表明初始化后的指针指向的地址是不能改变的，但这块地址上的存储的值可以改变，地址跟随一生。
7. 指针和引用的区别
**引用的底层本质：**

从高级语言层面的概念来说：引用是变量的别名，它不能脱离被引用对象独立存在。

